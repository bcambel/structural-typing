<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>structural-typing.preds documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Structural-typing 1.0.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>structural-typing</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>assist</span></div></div></li><li class="depth-3 branch"><a href="structural-typing.assist.defaults.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>defaults</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.lifting.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lifting</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.oopsie.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>oopsie</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.predicate-defining.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>predicate-defining</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.special-words.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>special-words</span></div></a></li><li class="depth-3 branch"><a href="structural-typing.assist.testutil.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>testutil</span></div></a></li><li class="depth-3"><a href="structural-typing.assist.type-repo.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>type-repo</span></div></a></li><li class="depth-2 branch"><a href="structural-typing.doc.html"><div class="inner"><span class="tree" style="top: -238px;"><span class="top" style="height: 247px;"></span><span class="bottom"></span></span><span>doc</span></div></a></li><li class="depth-2 branch"><a href="structural-typing.global-type.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>global-type</span></div></a></li><li class="depth-2 branch current"><a href="structural-typing.preds.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>preds</span></div></a></li><li class="depth-2"><a href="structural-typing.type.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>type</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="structural-typing.preds.html#var-all-of"><div class="inner"><span>all-of</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-at-most-keys"><div class="inner"><span>at-most-keys</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-exactly"><div class="inner"><span>exactly</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-exactly-keys"><div class="inner"><span>exactly-keys</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-implies"><div class="inner"><span>implies</span></div></a></li><li class="depth-1"><a href="structural-typing.preds.html#var-member"><div class="inner"><span>member</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">structural-typing.preds</h2><div class="doc"><div class="markdown"><p>Predefined predicates that are not imported into <code>structural-typing.type</code>.</p></div></div><div class="public anchor" id="var-all-of"><h3>all-of</h3><div class="usage"><code>(all-of &amp; condensed-type-descriptions)</code></div><div class="doc"><div class="markdown"><p>This is used with <a href="structural-typing.preds.html#var-implies">implies</a> to group a collection of <code>condensed-type-descriptions</code> into one. </p>
<pre><code> (all-of (requires :x :y) (includes :Point) {:color string?})
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L130">view source</a></div></div><div class="public anchor" id="var-at-most-keys"><h3>at-most-keys</h3><div class="usage"><code>(at-most-keys &amp; coll)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that&rsquo;s false when applied to a value with keys other than those given in <code>coll</code>. Note: the value may be <em>missing</em> keys in <code>coll</code>. See <a href="structural-typing.preds.html#var-exactly-keys">exactly-keys</a>.</p>
<pre><code>  user=&gt; (type! :X {:v1 string?
                    :v2 integer?}
                   (at-most-keys :v1 :v2))
  user=&gt; (built-like :X {:v1 &quot;apple&quot;})
  =&gt; {:v1 &quot;apple&quot;}
  user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3})
  =&gt; {:v1 &quot;apple&quot;, :v2 3}
  user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3, :actual-is-too-big true})
  Value has extra keys: #{:actual-is-too-big}; it is {:v1 &quot;apple&quot;, ...
  =&gt; nil
</code></pre><p>Note: this predicate works only with keys, not paths.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L47">view source</a></div></div><div class="public anchor" id="var-exactly"><h3>exactly</h3><div class="usage"><code>(exactly expected)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that&rsquo;s true iff the value it&rsquo;s applied to is <code>expected</code>.</p>
<pre><code>  (type! :V5 {:version (exactly 5)})
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L25">view source</a></div></div><div class="public anchor" id="var-exactly-keys"><h3>exactly-keys</h3><div class="usage"><code>(exactly-keys &amp; coll)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that&rsquo;s false when applied to a value with keys at all different than those given in <code>coll</code>. See <a href="structural-typing.preds.html#var-at-most-keys">at-most-keys</a> for a variant that allows the value to be missing some of the <code>coll</code> keys.</p>
<pre><code> user=&gt; (type! :X {:v1 string?
                   :v2 integer?}
                  (exactly-keys :v1 :v2))
 user=&gt; (built-like :X {:v1 &quot;apple&quot;})
 =&gt; Value has missing keys: #{:v2}; it is {:v1 &quot;apple&quot;}
 nil
 user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3})
 {:v1 &quot;apple&quot;, :v2 3}
 user=&gt; (built-like :X {:v1 &quot;apple&quot; :v2 3, :actual-is-too-big true})
 Value has extra keys: #{:actual-is-too-big}; it is {:v1 &quot;apple&quot;, ...
 =&gt; nil
</code></pre><p>Note: this predicate works only with keys, not paths.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L75">view source</a></div></div><div class="public anchor" id="var-implies"><h3>implies</h3><div class="usage"><code>(implies if-part then-part if-part then-part ...)</code></div><div class="doc"><div class="markdown"><p>There&rsquo;s enough going on with <code>implies</code> that it has its own  page in the user documentation: <a href="http://bit.ly/1LeLTy9">http://bit.ly/1LeLTy9</a>.</p><p>Both the <code>if</code> and <code>then</code> parts are either a single condensed type description (like <code>(requires :a :b :c)</code>) or a collection of them wrapped in <a href="structural-typing.preds.html#var-all-of">all-of</a>. </p><p>Each <code>if-part</code> is evaluated in turn. When the <code>if-part</code> matches the whole value, then the <code>then-part</code> is applied to check for type errors. Otherwise,the <code>then-part</code> is ignored (meaning that the whole expression reports no type errors).</p>
<pre><code> ;; If `:a` is present, `:b` must also be present:
 (type! :X (pred/implies :a :b))  

 ;; If `:a` is absent (or nil), `:b` must be odd.
 (type! :X (pred/implies {:a nil?} {:b [required-path odd?]}))

 ;; A use of `all-of`:
 (type! :X (pred/implies :a (pred/all-of (includes :Point)
                                         (requires :color))))
</code></pre><p>Warning: this &ldquo;predicate&rdquo; cannot be used outside of a structural-typing functions like <code>type!</code>, <code>named</code>, and <code>built-like</code>.</p></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L153">view source</a></div></div><div class="public anchor" id="var-member"><h3>member</h3><div class="usage"><code>(member coll)</code></div><div class="doc"><div class="markdown"><p>Produce a predicate that&rsquo;s false when applied to a value not a member of <code>coll</code>. The explainer associated with <code>member</code> prints <code>coll</code>.</p>
<pre><code>  (type! :small-primes {:n (member [2 3 5 7])})
</code></pre></div></div><div class="src-link"><a href="https://github.com/marick/structural-typing/blob/master/src/structural_typing/preds.clj#L12">view source</a></div></div></div></body></html>